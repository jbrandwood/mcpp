                    M C P P - P O R T I N G . T X T
                         == How to port MCPP ==

                    松井　潔    kmatsui@t3.rim.or.jp

V.2.0   1998/08     First released.
                                                                kmatsui
V.2.1   1998/09     Updated according to C99 1998/08 draft.
                                                                kmatsui
V.2.2   1998/11     Updated according to C++98 Standard.
                                                                kmatsui
V.2.3 prerelease 1      2002/08     Updated according to C99 Standard.
            Added porting to Linux / GCC, CYGWIN and LCC-WIN32.
            Augmented GCC-compatible features.
                                                                kmatsui
V.2.3 prerelease 2      2002/12     Added porting to GCC V.3.2.
            Revised some wording.
                                                                kmatsui
V.2.3 release       2003/02     Finally released.
                                                                kmatsui
V.2.3 patch 1       2003/03     Slightly modified.
                                                                kmatsui
V.2.4 prerelease    2003/11     Added porting to Visual C++.
            Created configure script.
                                                                kmatsui
V.2.4 release       2004/02     Extended multi-byte character handling.
            Added porting to Plan 9 / pcc.
                                                                kmatsui
V.2.4.1     2004/03     Revised recursive macro expansion, and added -c
                option.
                                                                kmatsui
V.2.5       2005/03     Absorbed POST_STANDARD into STANDARD as an
                execution time option, absorbed OLD_PREPROCESSOR
                setting as an execution option of PRE_STANDARD.
            Renamed most of #pragma __* directives as #pragma MCPP *.
            Removed documents on older compiler-systems (DJGPP,
                compiler-systems on MS-DOS except Borland C 4.0).
                                                                kmatsui
V.2.6       2006/07     Integrated STANDARD and PRE_STANDARD modes into
                one executable, differenciating the modes by the
                invocation options.
            Removed compiler-specific behaviors from stand-alone-build.
            Removed configurations for pre-C90 compilers, MS-DOS
                compilers and Plan 9 / cpp.
                                                                kmatsui

V.2.6.1     2006/08     Added porting to MinGW.
            Revised path-list handling for CygWIN.
            Revised some other points.
                                                                kmatsui



☆　目次　☆

１．概要
    [1.1]       ＯＳや処理系を選ばない portable なソース
    [1.2]       正確な Standard C モードに加えてその他の各種モードも
２．履歴
３．各処理系に移植する方法：概要
    [3.1]       移植ずみの処理系
        [3.1.1]     どの処理系でも必要な設定
        [3.1.2]     FreeBSD / GCC V.2.*, V.3.*, V.4.*
        [3.1.3]     Linux / GCC V.2.*, V.3.*, V.4.*
        [3.1.4]     CygWIN / GCC V.2.*, V.3.*
        [3.1.5]     MinGW / GCC V.3.*
        [3.1.6]     LCC-WIN32 V.3.*
        [3.1.7]     Visual C++ 2002, 2003, 2005
        [3.1.8]     Borland C V.4.*, V.5.*
    [3.2]       DECUS cpp で対応していた処理系
    [3.3]       noconfig.H, configed.H, system.H
    [3.4]       system.c
    [3.5]       lib.c
    [3.6]       標準ヘッダ
    [3.7]       makefile とMCPP を使ったリコンパイル
    [3.8]       MCPP をコンパイルできる処理系
    [3.9]       コンパイルする処理系とターゲットの処理系
    [3.10]      対応していない処理系
    [3.11]      Stand-alone 版のコンパイル
４．各処理系に移植する方法：詳細
    [4.1]       noconfig.H, configed.H, system.H の設定
        [4.1.1]     PART 1  ターゲットシステムの設定
            [4.1.1.1]   事前定義マクロ
            [4.1.1.2]   Include ディレクトリ等
            [4.1.1.3]   行番号情報の出力形式その他
            [4.1.1.4]   処理系の言語仕様に応じた設定
            [4.1.1.5]   Multi-byte character
            [4.1.1.6]   ターゲットとホストに共通の設定
        [4.1.2]     PART 2  ホストシステムの設定
        [4.1.3]     PART 3  MCPP の動作仕様の設定
            [4.1.3.1]   新旧各種の動作モード
            [4.1.3.2]   動作モードの細部の指定
            [4.1.3.3]   Translation limits の指定
    [4.2]       system.c
    [4.3]       lib.c
    [4.extra]   malloc()
５．バグ報告と移植の報告
    [5.1]       バグかどうか？
    [5.2]       malloc() 関連のバグチェック
    [5.3]       バグ報告を
    [5.4]       移植の報告を
    [5.5]       GCC 以外の処理系での configure の情報を
    [5.6]       データを送ってくれれば移植してみます
    [5.7]       検証セットによる他の処理系のテスト報告を
    [5.8]       改善のご意見を
６．MCPP の長い道のり
    [6.1]       構想３日、制作６年
    [6.2]       V.2.3 へ
    [6.3]       「未踏ソフトウェア創造事業」に採択


☆　１．概要　☆

  MCPP は Martin Minow の DECUS cpp を元に kmatsui（松井 潔）が全面的に
書き直したＣプリプロセッサです。MCPP という名前は Matsui cpp という意味
です。これはソースで提供するもので、各処理系で使うには、その処理系に合わ
せてソースに若干の変更を加えた上でコンパイルして、MCPP の実行プログラム
を作る必要があります。
  このドキュメントはソースを各処理系に移植する方法を説明しています。でき
あがった実行プログラムの動作仕様については、mcpp-manual.txt というマニュ
アルを参照してください。
  これらのソース、ドキュメントはすべて free software として提供します。
  MCPP は次のような特徴を持っています（この [1.1] - [1.2] は mcpp-manual.
txt と重複している）。

    [1.1]       ＯＳや処理系を選ばない portable なソース

  Linux, FreeBSD, Windows 等の多くのＯＳをサポートしている portable なプ
リプロセッサであり、そのソースは Standard C (ANSI/ISO/JIS C) の処理系ま
たは Standard C++ の処理系でさえあればコンパイルできる広い portability
を持っている。ライブラリ関数は古典的なものしか使っていない。
  各処理系に移植するためには、多くの場合、ヘッダファイル中のいくつかのマ
クロ定義を書き替えてコンパイルするだけですむ。最悪の場合でも、system.c
というソースファイルに数十行書き足す程度である。
  Multi-byte character（漢字）の処理は日本の EUC-JP, shift-JIS, ISO2022-
JP、中国の GB-2312、台湾の Big-5、韓国の KSC-5601 (KSX 1001) に対応して
いる。UTF-8 も使える。Shift-JIS や Big-5 の場合、コンパイラ本体が漢字を
認識しない処理系では、MCPP がそれを補う。

    [1.2]       正確な Standard C モードに加えてその他の各種モードも

  Standard C 準拠の動作モードのほかに、K&R 1st. のモードや "Reiser"
model cpp のモードもあり、さらには自称 post-Standard 仕様のモードまであ
る。C++ のプリプロセッサとして動作する実行時オプションもある。
  Standard C モードは既存の多くのプリプロセッサと違って、規格を完全に実
装しているつもりである。C90, C95, C99, C++98 のすべてに対応している。
Standard C プリプロセスの reference model となるものを目指して作ってある。
これらの規格のバージョンは実行時オプションで指定することができる。*1
  ほかにいくつかの有用な拡張機能も持っている。マクロの展開機序や #if 式
の評価機序をトレースする #pragma MCPP debug もある。ヘッダファイルを
"pre-preprocess" しておくこともできる。
  いくつかの有用な実行時オプションも備えている。ウォーニングのレベルを指
定するオプションや、include directory を指定するオプション等である。
  ソースにどんな間違いがあってもMCPP は暴走したり見当外れなメッセージを
出したりせず、正確でわかりやすい診断メッセージを出して適切な処理をする。
移植上で問題となる点についても警告を発する。
  高機能でありながら、コードサイズは比較的小さく、メモリ消費も比較的少な
い。
  詳細なドキュメントも付属している。

  MCPP の欠点を強いて挙げれば、速度がやや遅いことです。GCC V.3 / cc1 に
比べると２倍くらいの時間がかかります。しかし、Borland C 5.5 / cpp と同じ
くらいの速度で、ヘッダファイルの pre-preprocess の機能を使うともう少し速
くなるので、特に遅いほうではありません。正確であること、portable なソー
スであること、少ないメモリでも動作すること等のためには、この程度の処理時
間はやむをえないと考えています。

  なお、プリプロセッサの Standard C 準拠度をテストするための検証セットで
ある"Validation Suite for Standard C Preprocessing"、その解説およびそれ
を使ってテストした各種プリプロセッサの採点簿 cpp-test.txt を MCPP ととも
に公開しています。これを見ると、「Standard C 準拠」と称する既存のプリプ
ロセッサにいかに多くの問題があるかがわかります。*2

  *1 Ｃ言語の規格としては ISO/IEC 9899:1990 (JIS X 3010-1993) が長く使わ
    れてきたが、1999 年には ISO/IEC 9899:1999 が採択された。ここでは前者
    を C90、後者を C99 と呼ぶ。前者は ANSI X3.159-1989 が移行したものな
    ので、一般には ANSI C または C89 と呼ばれることもある。また、ISO/IEC
    9899:1990 + Amendment 1995 を C95 と呼ぶことがある。C++ の規格は ISO
    /IEC 14882:1998 およびその正誤訂正版である ISO/IEC 14882:2003 で、こ
    れをここでは C++98 と呼ぶ。
  *2 この cpp は V.2.2 までは単に cpp と呼んでいたが、一般の cpp と紛ら
    わしいので、V.2.3 からは MCPP と呼ぶことにした。このドキュメントでは
    V.2.2 までのバージョンも MCPP と呼ぶ。また、このドキュメントの名前は
    V.2.2 までは cpp.doc としていたが、V.2.3 からは porting.txt と変更し、
    さらに V.2.5 からは mcpp-porting.txt と変更した。私自身の名前も、V.2.
    2 までは Psycho としていたが、V.2.3 からは kmatsui と変更した。


☆　２．履歴　☆

    [2.1]  DECUS cpp は Martin Minow によって作られ、1984/05 に usenet /
net.sources で公開されました。DECUS というのは、DEC Users' Society とい
う DEC 社のコンピュータのユーザグループだそうです。DECUS cpp は DEC の
PDP-11 / RT11, PDP-11 / RSX, VAX / VMS, VAX / ULTRIX 等のシステムの当時
のＣ言語処理系のために書かれたＣプリプロセッサです。移植性の良い書き方が
されているので、他のシステムに移植することは比較的容易で、オリジナル版で
もすでに DEC 以外のいくつかの UNIX システムに対応していたようです。
    [2.2]  私が MCPP の出発点としたのは、C Users' Group の配付ディスク #
243 でした。このソース中にある修正履歴を見ると、原作者による最終修正が
85/06 となっています。その後、原作者がバージョンアップをしているのかどう
か、私は知りません。
    [2.3]  その後 88/12 までに何人かによって MS-DOS 上のいくつかの処理系
にも移植されました。CUG のディスクに入っているのはこのバージョンです。
    [2.4]  ftp.oreilly.com/pub/examples/imake/DECUS-cpp.tar.gz にもソー
スがあり、その time-stamp は 93/02 となっていますが、実際の内容は CUG の
ものより古く、85/01 のものです。なお、これに含まれている Martin Minow の
README によると、このプログラムは public domain となっています（この
README 自体も 84 または 85 年のものと思われる）。
    [2.5]  89/04 に Gigo らによって OS-9/6x09 の Microware C に移植され
たものが NIFTY-SERVE / FOS9 / lib 2 に登録されていました。
    [2.6]  MCPP V.2 は、私がこれらを元に全面的に書き直したものです。移植
性をさらに向上させ、Standard C に完全に対応させるため、ソースファイルの
分割の仕方も変え、多くのマクロを追加し、関数と変数の追加・分割・書き換え・
改名を大幅に行っています。ソースの量もオリジナル版の３倍になっています。
ドキュメントと検証セットはすべて、私がまったく新しく書いたものです。
  私はこれらを free software として公開します。私自身は DECUS とは何の関
係もありません。
  なお、オリジナル版には版数が付けられていませんが、MCPP と対比する時に
は、そちらを DECUS cpp と呼ぶことにします。
    [2.7]  Standard C のマクロ展開の実装方法については、E. Ream 作の MS-
DOS 上の PDS である CPP V.5.3 (1989/08, CUG #319) のソースも参考にさせて
いただきました。そのほか、GCC / cpp の動作や、J. Roskind の JRCPP のドキ
ュメントからもいくつかの示唆を得ています。
    [2.8]  MCPP V.2.0 は検証セット V.1.0 とともに 1998/08 に NIFTY SERVE
/ FC / LIB 2 で公開され、ベクター社のサイトにも転載されました。
    [2.9]  MCPP V.2.1 は、V.2.0 に C99 1998/08 draft に対応するための修
正を加えたものです。検証セット V.1.1 とともに 1998/09 に NIFTY SERVE /
FC / LIB 2 およびベクター社のサイトに同時にアプロードされました。
    [2.10] MCPP V.2.2 は V.2.1 を 1998/07 に決まった C++ Standard (ISO/
IEC 14882:1998) に対応して update したものです。検証セット V.1.2 ととも
に 1998/11 に NIFTY SERVE / FC / LIB 2 およびベクター社のサイトに同時に
アプロードされました。
    [2.11] MCPP V.2.3 は V.2.2 を C99 に対応して update し、さらに Linux
/ GCC 2.95, GCC 3.2 等への移植を追加して、GCC / cpp との互換性を向上させ
たものです。また、実行時オプションを追加し、一部を変更しました。V.2.3 で
はドキュメントの英語版も作成されました。MCPP に付属する検証セットには、
GCC / testsuite の一部として自動的にテストを実行することのできる edition
が追加されました。
    [2.12] MCPP は V.2.3 の開発の途中で、検証セット V.1.3 とともに、情報
処理推進機構(IPA) の平成１４年度「未踏ソフトウェア創造事業」に新部 裕・
プロジェクトマネージャによって採択され、2002/07 - 2003/02 の間は IPA の
資金援助と新部ＰＭの助言のもとに開発が進められました。英語版ドキュメント
もこのプロジェクトの中で、有限会社・ハイウェル（東京）に翻訳を委託し、そ
れに私が修正とテキスト整形を加えてできあがったものです。このプロジェクト
の中で cvs repository と ftp site が用意され、V.2.3 はそこで 2002/08 に
pre-release 1 が、2002/12 に pre-release 2 が、2003/02 にリリース版が開
発されました。その後、2003/03 に V.2.3 patch 1 が出されています。*
    [2.13] MCPP はさらに平成１５年度にも「未踏ソフトウェア創造事業」に伊
知地 宏 PM によって継続して採択され、2003/06 - 2004/02 の間は IPA の資金
援助と伊知地ＰＭの助言のもとに V.2.4 への update 作業が進められました。
そして、2003/11 には V.2.4 prerelease が開発されました。このバージョンで
は Visual C++ 2003 への移植が追加され、また、MCPP の make を自動化する
configure スクリプトが作成されました。なお、MCPP はそれまで明確なライセ
ンス表示をしていませんでしたが、この時から BSD スタイルのライセンス表示
をするようになりました。さらに、2004/02 にはリリース版が開発されました。
このバージョンでは multi-byte character の処理が拡張されました。また、英
語版ドキュメントもハイウェルに翻訳を委託し、日本語版に合わせて update さ
れました。
    [2.14] 2004/03 には MCPP V.2.4.1 がリリースされました。これは再帰的
マクロの展開方法を修正したものです。
    [2.15] 2005/03 には MCPP V.2.5 がリリースされました。このバージョン
では、POST_STANDARD というコンパイル時のモードは STANDARD モードにその実
行時オプションの一つとして吸収され、OLD_PREPROCESSOR というコンパイル時
の設定は PRE_STANDARD モードの実行時オプションとして吸収されました。再帰
的マクロの展開方法は再修正されて完全なものとなりました。また、GCC V.3.3,
3.4 に対応した一方で、16 ビットシステムでの処理系に関するドキュメントの
多くを削除しました。
    [2.16] 2006/07 には MCPP V.2.6 がリリースされました。このバージョン
では、STANDARD モードと PRE_STANDARD モードが１つの実行プログラムにまと
められました。stand-alone-build の仕様は処理系に依存しないものに改められ
ました。いくつかの処理系の新しいバージョンへの対応が追加された一方で、
pre-C90 の仕様の処理系に移植するための設定は削除されました。MS-DOS 上の
コンパイラへの移植も削除されました。ソースの書き換えは大幅なものになりま
した。今後はソースの追加や細部の修正はあっても、大幅な書き換えは発生しな
い見込みです。
    [2.17] 2006/08 には MCPP V.2.6.1 がリリースされました。このバージョ
ンでは、MinGW への移植が追加されました。そのほか、バグ修正といくつかの比
較的小さい改良がありました。

  * 「未踏ソフトウェア創造事業」(Exploratory Software Project) の概要は
    次のところで知ることができる。

        http://www.ipa.go.jp/jinzai/esp/

    MCPP V.2.3 から V.2.5 までは次のところに置いてきたが、

        http://www.m17n.org/mcpp/

    2006/04 に次のところに移った。

        http://mcpp.sourceforge.net/

    cpp V.2.2 はベクター社のサイトの次のところにある。dos/prog/c という
    ディレクトリに入れられているが、MS-DOS 専用ではない。ソースは UNIX,
    WIN32/MS-DOS 等に対応している。

        http://download.vector.co.jp/pack/dos/prog/c/cpp22src.lzh
        http://download.vector.co.jp/pack/dos/prog/c/cpp22bin.lzh
        http://download.vector.co.jp/pack/dos/prog/c/cpp12tst.lzh

    http://download.vector.co.jp/ は ftp://ftp.vector.co.jp/ でも同じよ
    うである。

    これらのアーカイブファイル中のテキストファイルは、Vector のものは
    DOS/Windows 系に合わせて、改行コードは [CR]+[LF]、漢字は shift-JIS
    で encode してある。SourceForge のものは V.2.5 までは UNIX 系に合わ
    せて改行コードは [LF]、漢字は EUC-JP である。V.2.6 からは [CR]+[LF]
    / shift-JIS の zip 版と [LF] / EUC-JP の tar.gz 版の２種類のアーカイ
    ブファイルを置くようにした。


☆　３．各処理系に移植する方法：概要　☆

  MCPP のソースは４本のヘッダファイルと８本の *.c ファイルからなっていま
す。ＯＳや処理系に依存する部分は configed.H, noconfig.H, system.H,
system.c の４本のソースにまとめてあります。configed.H と noconfig.H とは
同時に使われることはなく、必ずどちらか一方が使われます。また、ライブラリ
関数の一部のＣによるソースが lib.c にあります。したがって、MCPP を何らか
の処理系で使うには、それに合わせてこれらのソースファイルに変更を加える必
要があります。

  MCPP には２種類の build があります。１つは stand-alone-build で、処理
系からは独立して単体で動くものです。実行時オプションなどの仕様は一定で、
処理系依存の部分はありません。これはコンパイルさえ通ればすむのでごく簡単
です。これについては [3.11] で述べます。
  もう１つは処理系のプリプロセッサに代替して使う compiler-specific-build
です。処理系ごとに仕様が異なります。以下の [3.1] - [3.10] ではこの
compiler-specific-build を説明します。「GCC 版」「Visual C 用」等と表記
しているのはすべて、それぞれ GCC-specific-build, Visual C-specific-build
のことです。

  MCPP をコンパイルするには２つの方法があります。１つは configure スクリ
プトを実行して、config.h というヘッダファイルと Makefile を自動生成する
方法です。あとは単に make; make install とするだけですみます。configed.H
というヘッダファイルはこの場合に使われます。しかし、configure は UNIX 系
のシステムと CygWIN, MinGW でしか使えません。
  もう１つは各処理系用の差分ファイルを使ってヘッダファイルに変更を加え、
必要ならさらにヘッダファイルを編集した上で、その処理系専用の makefile を
使って make する方法です。noconfig.H というヘッダファイルはこの場合に使
われます。差分ファイルと makefile は noconfig というディレクトリにありま
す。Configure の使えるシステムでも、ヘッダファイルを直接、編集することで
細かい制御をすることができます。しかし、差分ファイルはすでに移植ずみの処
理系用のものしかありません。
  この章では差分ファイルを使う方法について説明します。Configure について
は INSTALL を見てください。

    [3.1]       移植ずみの処理系

  私自身が動かすことのできるＣ処理系は次のもので、このいずれにも MCPP を
移植してあります。すなわち、このソースをコンパイルでき、生成されたプリプ
ロセッサが正しく動作することを確認しています。いずれも CPU は x86 系を使
っています。*

    FreeBSD 5.3                 GCC V.3.4.2
    VineLinux 3.2               GCC V.2.95.3, V.3.2, V.3.3.2, V.3.4.3
    openSUSE Linux 10.0         GCC V.4.0.2
    CygWIN 1.3.10               GCC V.2.95.3
    CygWIN 1.5.18               GCC V.3.4.4
    MinGW (MSYS 1.0.11)         GCC V.3.4.5
    WIN32                       Visual C++ 2003, 2005
    WIN32                       Borland C++ V.4.0J, V.5.5J
    WIN32                       LCC-Win32 V.3.2, V.3.8

  これらの処理系で MCPP をコンパイルするための修正は簡単で、noconfig.H
の数個のマクロ定義を変更するだけです。
  noconfig ディレクトリの *.dif というファイルは FreeBSD 5.3 / GCC 3.4
用の noconfig.H を各処理系用に修正する差分ファイルです。Visual C++ 2005
を例にとると、src ディレクトリで

    patch -c < ..\noconfig\vc2005.dif

とすると、修正されます。patch は UNIX の標準的なコマンドで、Windows 等に
も移植されています。patch を使わなくても、差分ファイルを見てエディタで修
正してもかまいません。
  Include ディレクトリの指定などは、差分ファイルによる修正とは別に、ユー
ザが自分のシステムに合わせて修正しなければなりません。
  こうして修正したソースをコンパイルするための各処理系用の makefile も添
付してあります（[3.7] 参照）。

    copy ..\noconfig\visualc.mak Makefile

として src ディレクトリにコピーします。
  以下の作業も src ディレクトリで行います。作業は特に断らない限り、
noconfig.H の修正です。

  * このほか、MCPP V.2.2 までは次のものをサポートしていたが、その後、私
    はこれらの処理系を使わなくなった。V.2.3 ではソースとドキュメントに設
    定を残していたが、V.2.4 ではそれも削除した。

        MS-DOS                          Turbo C V.2.0
        OS-9/6x09 level 2               Microware C

      V.2.5 では次の処理系に関するドキュメントを削除した。

        GO32 / DJGPP V.1.12-M4          GCC V.2.7.1
        MS-DOS                          LSI C-86 V.3.3 試食版

      V.2.6 では上の２つの処理系の設定をソースからも削除し、さらに次の処
    理系に関するドキュメントとソースを削除した。

        MS-DOS / Borland C 4.0
        Plan 9 / pcc

        [3.1.1]     どの処理系でも必要な設定

  以下のどの処理系でも、compiler-specific-build を作るためには、

#define COMPILER        STAND_ALONE

となっている行を

#define COMPILER        MSC

等と、その処理系を表すマクロに変更します。そして、

#define VERSION_MSG     "GCC 3.4"

という行を次のように適宜書き換えます。

#define VERSION_MSG     "Visual C 2005"

  COMPILER の定義は make のオプションで上書きすることもできます。例えば、

    nmake COMPILER=MSC
    nmake COMPILER=MSC install

等とします。差分ファイルで noconfig.H を書き換えた場合は、compiler-
specific-build のための設定もその処理系用に書き換えられるので、COMPILER
は書き換える必要はありません。make で COMPILER を指定すると compiler-
specific-build が生成され、指定しないと stand-alone-build が生成されます。

  また、デフォルトの include directory の設定が noconfig.H のものと異な
る場合は、それを C_INCLUDE_DIR1, C_INCLUDE_DIR2 というマクロに書いておき
ます。C と異なる C++ 固有の include directory がある場合は、それを
CPLUS_INCLUDE_DIR1, CPLUS_INCLUDE_DIR2, CPLUS_INCLUDE_DIR3 に書きます
（これらのディレクトリは実行時に環境変数や -I オプションで指定することも
できる）。noconfig.H で設定するのは処理系固有の include directory です。
  Include directory はこのほか、system.c でも設定されています。UNIX で言
えば system.c で設定されるのはいわゆる OS-specific なもの（通常は /usr/
include）といわゆる site-specific なもの（通常は /usr/local/include）で
す。Windows では system.c では include directory は何も設定されません。
Windows では noconfig.H でもデフォルトでは include directory は設定され
ないので、自分で書くか、または環境変数 INCLUDE, CPLUS_INCLUDE で指定する
必要があります。
  また、必要なら CPU_STD1, CPU_STD2 等で定義される組み込みマクロ名も変更
します。

  Multi-byte character の encoding はデフォルトでは、UNIX 系では EUC-JP、
Windows では shift-JIS としていますが、必要なら MBCHAR というマクロを書
き換えて他の encoding に変更します。Multi-byte character encoding は実行
時に環境変数・オプション・#pragma で変更することもできます。
  処理系によっては shift-JIS や Big5 等の encoding に対応していないため、
multi-byte character の中に '\\' と同じ 0x5c の値のバイトがあると
tokenization でエラーになることがありますが、そういう処理系では MCPP は
特殊な処理をしてコンパイラの欠陥を補います。この設定については [4.1.1.5]
を見てください。
  添付の makefile については、処理系のバイナリの置かれているディレクトリ
の設定を必要に応じて書き換えます。

  GCC V.3, V.4 ではプリプロセスがコンパイラ (cc1, cc1plus) に吸収されて
しまったので、GCC-specific-build の MCPP を使うには、gcc, g++ の呼び出し
を shell-script に置き換えて、mcpp => cc1, mcpp => cc1plus の順序で実行
されるようにしなければなりません。添付の makefile では、

    make COMPILER=GNUC
    make COMPILER=GNUC install

とすると、これが自動的に設定されます。詳細については、mcpp-manual.txt [3.
9.7] を見てください。

        [3.1.2]     FreeBSD / GCC V.2.*, V.3.*, V.4.*

  ソースは FreeBSD 5.3 上の GCC (GNU C) V.3.4.* でコンパイルして stand-
alone-build の MCPP を生成する状態になっています。FreeBSD 5.3 / GCC V.3.
4.* 用の compiler-specific-build を作るには、

#define COMPILER        STAND_ALONE

となっている行を

#define COMPILER        GNUC

として、コンパイルすればできあがりです。
  GCC の他のバージョンであれば、VERSION_MSG というマクロおよび

#define COMPILER_EXT_VAL    "3"
#define COMPILER_EXT2_VAL   "4"
#define COMPILER_CPLUS_VAL  "3"

となっているところのバージョン番号を変更します。COMPILER_EXT_VAL は GCC
の major version number を、COMPILER_EXT2_VAL は minor version number を
書きます。COMPILER_CPLUS_VAL は __GNUG__ マクロの値で、COMPILER_EXT_VAL
と同じになります。

  FreeBSD のバージョンが 5.* でなければ、

#define SYSTEM_EXT_VAL  "5"     /* V.4.*: 4, V.5.*: 5   */

の値を変更します。
  さらに include directory が FreeBSD 5.3 の標準と違っている場合は、

#define CPLUS_INCLUDE_DIR1  "/usr/include/c++/3.4"
#define CPLUS_INCLUDE_DIR2  "/usr/include/c++/3.4/backward"

となっているディレクトリを変更します。CPLUS_INCLUDE_DIR3, C_INCLUDE_DIR1
の設定も必要かもしれません。

  GCC V.2.7-2.95 であれば次のマクロの定義を 199409L に変更します。

#define STDC_VERSION        0L

  他の UNIX 系 OS でもコンパイラが GCC であれば、このバージョン表示や、
include ディレクトリの設定、ＯＳ固有の組み込みマクロの設定、等を変えるだ
けですむのではないでしょうか（[4.1.1] 参照）。

        [3.1.3]     Linux / GCC V.2.*, V.3.*, V.4.*

  Linux / GCC ではまず、

#define SYSTEM      SYS_FREEBSD

を

#define SYSTEM      SYS_LINUX

に変更し、

#define COMPILER_SP3_VAL    "int"

を

#define COMPILER_SP3_VAL    "long int"

に変更します。
  そして、FreeBSD の場合と同じように、COMPILER, VERSION_MSG,
COMPILER_EXT_VAL, COMPILER_EXT2_VAL, COMPILER_CPLUS_VAL,
CPLUS_INCLUDE_DIR1, CPLUS_INCLUDE_DIR2, C_INCLUDE_DIR1 等のマクロの値を
変更します。
  GCC 2.* では STDC_VERSION の値を変更します。
  include directory は

    echo '' | gcc -xc -E -v -
    echo '' | g++ -xc++ -E -v -

として確かめてから設定してください。

  noconfig ディレクトリの linux_gcc2953.dif, linux_gcc32.dif,
linux_gcc332.dif, linux_gcc343.dif はFreeBSD / GCC V.3.4 用のソースを
VineLinux 3.* / GCC V.2.95.3, V.3.2, V.3.3.2, V.3.4.3 用に修正する差分フ
ァイルです。linux_gcc402.dif は openSUSE Linux / GCC V.4.0.2 用のもので
す。それぞれ compiler-specific-build ではさらに COMPILER を変更します。
Distribution の標準の GCC と追加インストールした GCC とで include
directory がかなり異なる点に注意してください。
  なお、glibc の getopt() は POSIX 等の標準のものとは仕様が異なるので、
使わずに、lib.c のものを使ってください。noconfig.H は Linux ではデフォル
トで glibc が使われていると判断します。

        [3.1.4]     CygWIN V.1.* / GCC V.2.*, 3.*

  CygWIN V.1.3.10 / GCC V.2.95.3 では noconfig.H に cyg1310.dif にあるよ
うな変更を加えます。CygWIN V.1.5.18 / GCC V.3.4.4 では cyg1518.dif を使
います。
  さらに CYGWIN_ROOT_DIRECTORY というマクロを自分の環境に合わせて修正し
ます。これは CygWIN の存在する Windows 上のディレクトリを次の形式で定義
するものです。

    #define CYGWIN_ROOT_DIRECTORY   "c:/pub/compilers/cygwin"

path-list 中の大文字・小文字は関係ありません。

  他の version でも、VERSION_MSG, CYGWIN_ROOT_DIRECTORY, include
directory のマクロを変更することで対応できるでしょう。

  CygWIN は Windows 上のシステムですが、UNIX のファイルシステムがシミュ
レートされているので、MCPP では UNIX 系システムの GCC とほぼ同様に扱いま
す。Include directories も UNIX 系と同様に組み込まれます。

        [3.1.5]     MinGW / GCC V.3.*

  MinGW / GCC V.3.4.5 では noconfig.H に mingw345.dif のような変更を加え
ます。
  さらに MSYS_ROOT_DIRECTORY, MINGW_DIRECTORY という２つのマクロを自分の
環境に合わせて修正します。これは次のように、それぞれ /, /mingw ディレク
トリの Windows 上の位置に定義するものです。

    #define MSYS_ROOT_DIRECTORY "C:/Program Files/MSYS/1.0"
    #define MINGW_DIRECTORY     "C:/Program Files/MinGW"

path-list 中の大文字・小文字は関係ありません。
  他の version でも、これらのマクロと VERSION_MSG, include directory の
マクロを変更することで対応できるでしょう。Include directory のマクロ定義
は "C:/dir/mingw/include" という絶対パスでも、"/mingw/include" という
MinGW 内のディレクトリでもかまいません。

  MinGW では symbolic link がサポートされていないので、gcc から GCC-
specific-build の MCPP を起動するのに symbolic link が使えません。その上、
MinGW / gcc はたとえ cc1 という名前でも shell-script の起動は拒否します。
そこで、MCPP のコンパイルでは cc1.exe という実行プログラムを生成して、こ
の中から mcpp,exe または GCC の cc1.exe, cc1plus.exe を呼び出します。こ
のため、make では次のように mcpp, cc1 の２つのターゲットを指定する必要が
あります。

    make COMPILER=GNUC mcpp cc1

  MinGW の GCC-specific-build では include directories は MCPP が設定し
ますが、stand-alone-build では設定されないので、環境変数 INCLUDE,
CPLUS_INCLUDE で指定する必要があります。

        [3.1.6]     LCC-WIN32 V.3.*

  LCC-WIN32 V.3.2, V.3.8 ではそれぞれ lcc32.dif, lcc38.dif のような変更
を加えます。
  他の version では VERSION_MSG マクロを変更します。
  LCC-WIN32 の long long にはかつてはバグがあって使えませんでしたが、少
なくとも V.3.2 (2003/08) 以降ではちゃんと使えるようになっています。

        [3.1.7]     Visual C++ 2002, 2003, 2005

  Visual C++ 2005, 2003, 2002 ではそれぞれ vc2005.dif, vc2003.dif,
vc2002.dif のような変更を加えます。もちろん、compiler-specific-build で
は COMPILER マクロを書き換えるか、nmake -DCOMPILER=MSC オプションで上書
きします。
  Visual C の他のバージョンでは、VERSION_MSG マクロを変更するほか、
_MSC_VER および _MSC_FULL_VER という組み込みマクロの値をそれぞれ
COMPILER_EXT_VAL, COMPILER_EXT2_VAL というマクロの設定を変えることで対応
させます。

        [3.1.8]     Borland C++ V.4.*, V.5.*

  Borland C V.4.0, V.5.5 / bcc32 ではそれぞれ bc40.dif, bc55.dif のよう
な変更を加えます。
  Borland C/C++ の別のバージョンでは VERSION_MSG のほか、__TURBOC__,
__BORLANDC__, __BCPLUSPLUS__ という組み込みマクロの値をそれぞれ noconfig.
H の COMPILER_STD2_VAL, COMPILER_EXT_VAL, COMPILER_CPLUS_VAL というマク
ロの設定を変えることで、対応させます（[4.1.1.1] 参照）。Digraphs の実装
されているバージョンであれば、HAVE_DIGRAPHS の設定を変更します。
__STDC_VERSION__ の実装されているバージョンであれば、STDC_VERSION の設定
を変更します。
  また、Borland C 4.* までのバージョンでは、

#define SEARCH_INIT         CURRENT

とします。

    [3.2]       DECUS cpp で対応していた処理系

  PDP-11 上の RT-11 / DECUS C, RSX / DECUS C、VAX 上の VMS / VAX-11 C、
PDP-11 / UNIX, VAX / ULTRIX の何かのＣ (pcc ?) には DECUS cpp が対応して
いたようです。MS-DOS 上の Microsoft C, Lattice C のかなり古い版にも対応
していたようです。これらはさすがにもう不要と思われ、また私自身がメンテナ
ンスできないので、削除しました。

    [3.3]       noconfig.H, configed.H, system.H

  system.H は HAVE_CONFIG_H というマクロが 1 に定義されていると configed.
H を include し、そうでなければ noconfig.H を include します。configed.H,
noconfig.H には MCPP の設定の PART 1 と PART 2 という部分があり、system.
H には PART 3 があります。
  これらのファイルには、各処理系に移植する時に必要ないくつかのマクロが定
義されています。まだ移植されていない処理系に移植するには、PART 1 に数行
ないし十数行を書き足します。
  PART 1 はＯＳと target 処理系に依存する定義で、PART 2 は host 処理系に
依存する定義、そして PART 3 は MCPP の動作仕様の定義です。
  configed.H, noconfig.H ではターゲット処理系とホスト処理系とが同じであ
ると仮定していますが、異なる場合は PART 2 を編集する必要があります。
  デフォルトの設定と違う設定で移植する場合は、これらのファイルの全体に必
ず目を通してください。

    [3.4]       system.c

  configed.H (noconfig.H), system.H のマクロだけでは吸収できないＯＳや処
理系の差異は、system.c で吸収しています。未実装の処理系に移植するには、
ここに数十行のソースを書き足すことが必要になるでしょう。
  このファイルに記述されているのは、MCPP 起動時のオプション、usage 文、
include ディレクトリ、ヘッダファイルやソースファイルをオープンする時のＯ
Ｓ固有のディレクトリパスの扱い、#pragma の処理、処理系固有の拡張ディレク
ティブの処理、等です。ほとんどは target OS と target 処理系の設定です。

    [3.5]       lib.c

  ライブラリ関数のうち、Standard C にない getopt(), stpcpy() のＣによる
ソースをここに書いてあります。MCPP は getcwd() も使い、UNIX 系では
readlink() も使いますが、この２つは OS に依存する関数であり portable に
書くことができないので、lib.c には含めていません。この２つは Standard C
にはありませんが、POSIX では規定されています。MCPP の使う低水準関数はこ
の２つだけです。これらを持たない処理系はないでしょう。*
  MCPP V.2.5 までは fgets(), memmove(), memcmp(), memcpy(), strstr(),
strcspn() のソースも用意していましたが、これらの関数が必要な処理系はもは
やないと思われるので、削除しました。
  ライブラリ関数はいずれも、処理系によって微妙に違う恐れのある仕様に依存
した使い方はしていないので、どの処理系のものでもバグさえなければ大丈夫で
す。
  lib.c 中の xyz という関数を使うには、noconfig.H (configed.H) の PART 2
にある HOST_HAVE_XYZ というマクロを FALSE に定義します。

  * MinGW 版に限って spawnv() も使われる。

    [3.6]       標準ヘッダ

  MCPP のソースでは stdio.h, ctype.h, errno.h, stdlib.h, string.h,
stddef.h, time.h を無条件で include しています。UNIX 系のシステムでは
unistd.h も include します。これらを持たない処理系はまずないでしょう。

    [3.7]       makefile と MCPP を使ったリコンパイル

  noconfig ディレクトリにある *.mak は個別の処理系用の makefile です。詳
細な設定ができます。make そのものは各処理系に付属のもの、またはそのシス
テムの標準的なものを想定しています。Visual C では make ではなく nmake を
使います。
  まず、処理系を xyz とすると、FreeBSD / GCC 以外では

    patch -c < ../noconfig/xyz.dif

として noconfig.H を修正します。次に、noconfig.H の COMPILER と
VERSION_MSG というマクロを書き換えます。さらに自分のシステムに合わせて
noconfig.H の C_INCLUDE_DIR? 等のマクロを修正します。そして、使用する
noconfig/xyz.mak を Makefile にコピーし、ディレクトリ指定等を自分のシス
テムに合わせて修正した上で、

    make
    make install
    make clean

としてください。
  他の処理系では、これらを参考に必要な makefile を書いてください。ソース
の依存関係は単純で、

    main.c, control.c, eval.c, expand.c, support.c, system.c, mbchar.c
        は system.H, internal.H に依存する
    lib.c は configed.H (noconfig.H) に依存する
    system.H は configed.H (noconfig.H) に依存する

という関係になっています。system.H は internal.H より先に include する必
要があります。
  スタックサイズはシステムの使う分に次の分くらいが必要です（NMACWORK,
NEXP, RESCAN_LIMIT は system.H で定義されているマクロ）。

    NMACWORK + (NEXP * 30) + (sizeof (int) * 100)
        + (sizeof (char *) * 12 * RESCAN_LIMIT)

  Windows のようにワイルドカードを shell（コマンドプロセッサ）が展開しな
いシステムでは、MCPP でも展開しないようにコンパイルしておいたほうが安全
です（-o オプションが指定されない限り、第２引数が出力ファイルの指定とみ
なされるので）。

  MCPP 自身を使って MCPP をリコンパイルするには、処理系のプリプロセッサ
のあるべき場所にこの実行プログラムをおきます。例えば GCC V.2.95 であれば、
処理系付属の cpp0 を cpp0_gnuc とでも rename しておき、その時に使うもの
を cpp0 にリンクするのが良いでしょう。すなわち、使うプリプロセッサを
mcpp とすると、

    ln -sf mcpp cpp0

とします。Windows では使うものを cpp32.exe 等にコピーします。*
  MCPP 実行プログラムの名前は

    make NAME=mcpp

等として指定することができます（同じことを BC make では make
-DNAME=mcpp とする。UCB make では -D は付けても付けなくても良い。GNU
make では -D は付けてはいけない）。
  添付の makefile では freebsd.mak, linux.mak 以外は make install ではこ
まかい処理はしないので、手で補ってください。処理系付属のプリプロセッサは、
make install で消してしまうことのないように、あらかじめ別名のファイルに
コピーしておいてください。
  Visual C, Borland C のような１パスコンパイラで MCPP を使ってリコンパイ
ルする場合は、MCPP の出力ファイルをコンパイラに与えるソースファイルとし
ます（例えば main.c というソースをプリプロセスしたものを main.i といった
名前で出力して、それを cl や bcc32 にコンパイルさせる）。

  MCPP を使ってリコンパイルする時は、ヘッダファイルの "pre-preprocess"
の機能を使うと、プリプロセス時間が大幅に短縮されます。添付の makefile を
使う場合は、UCB make, GNU make, MS nmake では、

    make PREPROCESSED=1

BC make では

    make -DPREPROCESSED=1

とすると、自動的にヘッダファイルを pre-preprocess した上でプリプロセスし、
それからコンパイルします。LCC-Win32 の make では if 文による場合分けがで
きないので、makefile を修正してリコンパイルする必要があります。修正の内
容は makefile そのものにコメントとして書いてあります。

  UCB make, GNU make, MS nmake では、MALLOC=KMMALLOC というオプションを
付けて make すると、私が書いた malloc() をリンクします。これについては
[4.extra] を見てください。BC make では同じことを -DKMMALLOC というオプシ
ョンで指定します。LCC-Win32 make で私の malloc() をリンクするためには、
makefile を修正する必要があります。

  * FreeBSD では cpp0, cc1 を置く標準のディレクトリは /usr/libexec であ
    る。
    Linux では /usr/lib/gcc-lib/i686-redhat-linux/3.3.2 といったひどく奥
    深いディレクトリになっている。Linux / GCC では distribution やその
    version に応じて makefile のこのディレクトリの指定を書き換える必要が
    ある。Include directory もいろいろあるので、確かめなければならない。
    また、Linux や FreeBSD では /usr/bin/cpp というものがあるが、これは
    実際には cpp0 または cc1 を呼び出す。gcc も cpp0 または cc1 を呼び出
    す。
    なお、mcpp-manual.txt [3.9.5], [3.9.7] も参照のこと。GCC 3.*, 4.* で
    はプリプロセスがコンパイラ (cc1, cc1plus) に吸収されてしまったので、
    MCPP を使うには gcc, g++ の呼び出しを shell-script に置き換える必要
    がある。

    [3.8]       MCPP をコンパイルできる処理系

  各処理系に移植するためにはいくつかの設定が必要ですが、MCPP のソースを
コンパイルすること自体は、C90 (ANSI C) の仕様を満たしている処理系であれ
ば十分できます。プリプロセッサも同様です。*
  C++ でもコンパイルできます（C++ であるかどうかは、#ifdef __cplusplus
で判断している）。次の手順でコンパイルします。

  1.  lib.c 以外の *.c を *.cc あるいは *.cpp と rename する。
  2.  make する。MCPP を使って "pre-preprocess" する場合は cpp に -+ オ
プションを付ける。

  添付の *.mak では、処理系によって make に CPLUS=1 または -DCPLUS=1 の
オプションを付けて起動します。
しかし、C++ でコンパイルしてもメリットは何もありません。

  char 型は符号付きでも符号なしでもかまいません。
  浮動小数点演算は不要です。

  このソースは処理系の微妙な差に影響されないように書いてあります。もっと
も、実際に各処理系でコンパイルするためには、さらにその処理系のバグも回避
する必要があります。これはやってみないと何が出てくるかわかりません。私が
移植したいくつかの処理系でも、バグであることを確かめその回避方法を見つけ
るまでにかなりの時間がかかってしまったことが何回かあります。

  * MCPP V.2.5 までは K&R 1st. の処理系でもコンパイルできるようにしてい
    たが、すでにその必要はなくなっていると思われるので、V.2.6 からは C90
    を前提とするように改めた。それに伴ってソースを整理し、このドキュメン
    トも整理した。

    [3.9]       コンパイルする処理系とターゲットの処理系

  MCPP のソースをコンパイルする処理系（ホスト）と、それによって生成され
た MCPP の実行プログラムを使う処理系（ターゲット）とは、必ずしも同じであ
る必要はありません。これが違っている場合は、noconfig.H (configed.H) の
SYSTEM, COMPILER でターゲットを指定し、HOST_SYSTEM, HOST_COMPILER はホス
トを指定します。また、PART 1 にある諸定義はターゲット用のもので、PART 2
にあるものはホスト用の設定です。system.c は主としてターゲット用のもので
す。lib.c はホスト用の設定でコンパイルします。

  ホストとターゲットの関係には、次のような制限があります。
  １．ホスト処理系はターゲット処理系と同じＯＳ上のものであるか、またはク
ロスコンパイラであることが必要です。
  ２．ホスト処理系の long (unsigned long) はターゲット処理系のそれより範
囲が狭くてはいけません。これは Standard C で規定されている条件でもありま
す。C99 では long long (unsigned long long) について同じことが言えます。

  なお、ここで言うホストとターゲットというのは、クロスコンパイラのそれと
は関係ありません。クロスコンパイルするのはコンパイラ本体の仕事で、プリプ
ロセッサは原則としてそれには関知しません。MCPP を「クロスコンパイラに」
移植する場合は、そのクロスコンパイラがここで言うターゲット処理系です。ホ
スト処理系としてはクロスコンパイラでないものを使うことになるはずです。
MCPP を「クロスコンパイラで」コンパイルする場合は、そのクロスコンパイラ
がホスト処理系で、クロスコンパイラのターゲットがターゲット処理系となりま
す。
  ただし、MCPP では、MCPP をコンパイルするホスト処理系の文字セットとそれ
を使うターゲット処理系の文字セットとはともに ASCII であると仮定していま
す。クロスコンパイラのホストとターゲットの文字セットについても同様です。

    [3.10]      対応していない処理系

  MCPP が対応していないのは、特殊な文字セットを持つ処理系と特殊な CPU で
す。
  EBCDIC には対応していません。
  また、整数演算が２の補数でない CPU にも、対応していません。２の補数で
ない場合は、#if 式でオーバーフローが発生した時に、おかしくなるかもしれま
せん。

    [3.11]      Stand-alone 版のコンパイル

  MCPP を処理系からは独立して単体で動く stand-alone 版としてコンパイルす
ることもできます。これはコンパイルさえ通ればすむので簡単です。Stand-
alone 版は実行時オプションなどの仕様は一定で、処理系依存の部分はありませ
ん。OS による相違が少しあるだけです。include directory も UNIX 系で /usr
/include, /usr/local/include が設定されるだけなので、あとは環境変数や -I
オプションで指定する必要があります。*

  configure が使えるシステムで GCC でコンパイルする場合は単に mcpp のル
ートディレクトリで

    ./configure; make; make install

とすればすみます。この場合は noconfig.H ではなく configed.H というヘッダ
ファイルが使われます。configure の詳細については INSTALL-jp を参照してく
ださい。

  configure の使えないシステムでも MCPP がすでに移植されている処理系では、
noconfig ディレクトリにある所定の差分ファイルを使って noconfig.H を書き
換えればすみます。それ以外の変更は必要ありません。makefile も noconfig
ディレクトリにあるものをコピーして使います。インストールするディレクトリ
は makefile 中の BINDIR という変数に書きます。そして、src ディレクトリで
make し、make install します。
  MCPP がすでに移植されている処理系とバージョンが少し違うだけの場合は、
まず近いバージョンの差分ファイルを適用して、それを編集します。

  MCPP がまだ移植されていない処理系では、noconfig.H を編集して数個のマク
ロを書き換えたり書き加えたりしてください。まず、HOST_COMPILER を適宜定義
します。Stand-alone 版では COMPILER を STAND_ALONE に定義し、SYSTEM をそ
の OS に定義し、VERSION_MSG を適宜定義します。ターゲット処理系は存在しな
いので、PART 1 には設定することはありません。

  PART 2 は MCPP をコンパイルするホスト処理系が Standard C の仕様をどれ
だけ実装しているか、必要な関数を持っているかによって、設定が違ってきます。
最も違うのは long long という型の実装です。Visual C 2002, 2003, 2005 や
Borland C 5.5 等では __int64 という型になっていて、その値を printf() で
表示する指定子が VC 2005 以外では j や ll ではなく I64 なので、LL_FORM
というマクロを "I64" に定義します。MinGW では long long がありますが、
printf() の指定子は I64 です。
  stpcpy(), getopt() という関数のない処理系では、それぞれ
HOST_HAVE_STPCPY, HOST_HAVE_GETOPT を FALSE に定義します。

  makefile は noconfig ディレクトリにあるものを参考にして書いてください
（[3.7] も参照のこと）。

  * MCPP V.2.4, V.2.5 では stand-alone 版の仕様は中途半端で、処理系の仕
    様に対応した単体のプリプロセッサであった。V.2.6 からは処理系から独立
    した一定の仕様とした。


☆　４．各処理系に移植する方法：詳細　☆

    [4.1]       noconfig.H, configed.H, system.H の設定

  これらのヘッダファイルに記述されていることの意味は、たいていは読めばわ
かると思います。コメントも多く書き込んであります。さらに念のために以下に
注釈を書いておきます。
  設定の PART 1, PART 2 は noconfig.H (configed.H) にあり、PART 3 は
system.H にあります。

  まず、ターゲットシステム（MCPP を移植するシステム）とホストシステム
（MCPP をコンパイルするシステム）を指定します。

SYSTEM
    ターゲット処理系が動くＯＳを指定します。ＯＳの名前はこの直後に定義さ
    れています。名前が定義されていないＯＳは適宜定義してください。
COMPILER
    ターゲット処理系を指定します。コンパイラの名前はこの直後に定義されて
    います。名前が定義されていないコンパイラは適宜定義してください。
    COMPILER を STAND_ALONE に定義すると、ターゲット処理系の存在しない
    stand-alone 版の MCPP が生成されます。この場合は PART 1 の多くの設定
    が無視されます。
VERSION_MSG
    -v オプションや usage() 文で表示するためのホスト処理系のバージョン情
    報を文字列リテラルで書きます。
HOST_SYSTEM, HOST_COMPILER
    ホストＯＳ、ホスト処理系を指定します。ターゲットと同じ場合は、

    #define HOST_SYSTEM     SYSTEM
    #define HOST_COMPILER   COMPILER

    としておきます。

  SYSTEM, COMPILER の命名には一定の規則がありますが、ソースを見たほうが
わかりやすいでしょう。いささか仰々しい形になっていますが、SYSTEM はイン
クルードファイルのパスリストの形式やＯＳ標準のインクルードディレクトリ等
を知るためにしか使われていないので、あまり考える必要はありません。

    [4.1.1]     PART 1  ターゲットシステムの設定

        [4.1.1.1]   事前定義マクロ

CPU_OLD, CPU_STD1, CPU_STD2, SYSTEM_OLD, SYSTEM_STD1, SYSTEM_STD2,
SYSTEM_EXT, SYSTEM_EXT2, COMPILER_OLD, COMPILER_STD1, COMPILER_STD2,
COMPILER_EXT, COMPILER_EXT2
    MCPP で pre-define する処理系固有のマクロの名前を文字列リテラルで指
    定します。不要なものは定義しないでおきます（0 個のトークンに定義して
    はいけない）。*_OLD で生成されるのは '_' (underline) で始まらない古
    い流儀のマクロで、これらは MCPP 実行時に -S <n> オプションで <n> に
    1 以上を指定すると pre-define されません。*_STD?, *_EXT, *_EXT2 では
    必ず _ で始まるマクロ名を指定します。*_STD1 は __ で始まるもので、*
    _STD2 は __ で始まって __ で終わるものです。SYSTEM_EXT, SYSTEM_EXT2,
    COMPILER_STD1, COMPILER_STD2, COMPILER_EXT, COMPILER_EXT2 ではそのマ
    クロの値も SYSTEM_EXT_VAL, SYSTEM_EXT2_VAL, COMPILER_STD1_VAL,
    COMPILER_STD2_VAL, COMPILER_EXT_VAL, COMPILER_EXT2_VAL で指定します。
    これは整数を "" で囲んだ文字列リテラルで指定します。0 個のトークンに
    展開されるマクロは "" と定義します。指定されなければ、そのマクロの値
    は 1 になります。その他の predefined マクロ（CPU_*, SYSTEM_OLD,
    SYSTEM_STD1, SYSTEM_STD2, COMPILER_OLD で指定されるもの）はすべて 1
    の値を持ちます。
CPU_SP_OLD, CPU_SP_STD
    処理系固有の特殊な事前定義マクロの名前を文字列リテラルで書きます。値
    はすべて 1 となります。
SYSTEM_SP_OLD, SYSTEM_SP_STD
    処理系固有の特殊な事前定義マクロの名前を文字列リテラルで書き、その値
    を SYSTEM_SP_OLD_VAL, SYSTEM_SP_STD_VAL で定義します。
COMPILER_SP1, COMPILER_SP2, COMPILER_SP3
    処理系固有の特殊な事前定義マクロの名前を文字列リテラルで書き、その値
    を COMPILER_SP1_VAL, COMPILER_SP2_VAL, COMPILER_SP3_VAL で定義します。
COMPILER_CPLUS, COMPILER_CPLUS_VAL
    -+ オプション（C++ プリプロセス）を指定した時に定義される処理系固有
    の事前定義マクロの名前とその値を上記と同じように文字列リラテルで指定
    します。COMPILER_CPLUS_VAL を指定しないと、そのマクロの値は 1 になり
    ます。名前は '_' で始まるものでなければなりません。必要がなければ
    COMPILER_CPLUS そのものを定義しないでおきます。

  このほか、実行時オプションに応じて system.c で定義される事前定義マクロ
もあります。GCC V.3.3 以降では大量の事前定義マクロがあるので、これらの設
定とは別に mcpp_g*.h という名前の４本の専用のヘッダファイルが MCPP のイ
ンストール時に自動的に生成されます。
  以上の設定で事前定義されたマクロはすべて -N オプションで無効となります。

        [4.1.1.2]   Include ディレクトリ等

C_INCLUDE_DIR1, C_INCLUDE_DIR2, CPLUS_INCLUDE_DIR1, CPLUS_INCLUDE_DIR2,
CPLUS_INCLUDE_DIR3
    MCPP でサーチする標準ヘッダファイルの include directory を指定します。
    CPLUS_INCLUDE_DIR? は C++ の include directory がＣのものと違ってい
    る場合に、設定します（MCPP を起動する時に -+ オプションを指定するこ
    とで有効となる）。UNIX の /usr/include, /usr/local/include は
    system.c で設定されるので、C_INCLUDE_DIR? にはそれ以外の処理系固有の
    ものを指定します。
ENV_C_INCLUDE_DIR, ENV_CPLUS_INCLUDE_DIR
    MCPP でサーチする標準ヘッダファイルの include directory を実行時に環
    境変数で指定する場合のために、その環境変数の名前に定義します。
    ENV_CPLUS_INCLUDE_DIR は C++ の include directory を指定する環境変数
    の名前です。デフォルトではそれぞれ "INCLUDE", "CPLUS_INCLUDE" に定義
    されます。GCC-specific-build では "C_INCLUDE_PATH",
    "CPLUS_INCLUDE_PATH" がデフォルトです。
    サーチパスはその外、system.c で設定されるもの、-I オプションで設定さ
    れるものがあります（それらの優先順位については mcpp-manual.txt [4.2]
    を参照）。
ENV_SEP
    この環境変数に複数のパスを書く時の separator を文字定数で書きます。
    /usr/local/abc/include:/usr/local/xyz/include と書く時の ':' や
    C:BC55/INCLUDE;C:BC55/LOCAL/INCLUDE と書く時の ';' がこれです。
SEARCH_INIT
    ターゲット処理系が include ファイルをサーチする時のルールを書きます。
    #include "../dir/header.h" といったディレクティブを処理する時に、
    include ディレクトリをサーチする前にどのディレクトリをサーチするのか
    というルールです。カレントディレクトリからの相対パスをサーチする処理
    系では CURRENT とし、ソースファイル（include 元）のあるディレクトリ
    からの相対パスをサーチする処理系では SOURCE とします。この両者の組合
    わせである場合は (CURRENT & SOURCE) とします。

        [4.1.1.3]   行番号情報の出力形式その他

LINE_PREFIX
    MCPP から compiler-proper にファイル名と行番号情報を伝える形式を設定
    します。

    #line 123 "fname"

    というＣのソースの形式がデフォルトとなっています。その他の形式を使う
    処理系では、この "#line " の部分を置き換える sequence を文字列リテラ
    ルで書いておきます。

    # 123 "fname"

    という形式なら "# " と定義し、どちらでもない独自の形式ならそれに合わ
    せて定義します（場合によっては main.c の sharp() 等に書き足さなけれ
    ばならないかもしれない）。
    Visual C++ .net や Borland C のような１パスコンパイラの前段に MCPP
    を使う場合は、組み込みプリプロセッサに出力を渡すことになるので、MCPP
    の出力はＣのソースになっていなければなりません。したがって、行番号の
    受け渡しは１番目の形式でなければなりません。

EMFILE
    <errno.h> で too many open files (for the process) を意味する errno
    の値を表すマクロが EMFILE でない場合は、EMFILE をそのマクロ名に定義
    します（もちろん、<errno.h> 自体に書き加えてもかまわない）。
ONE_PASS
    ターゲット処理系がプリプロセッサの分離されていないいわゆる「ワンパス
    コンパイラ」であればこれを TRUE に、そうでなければ FALSE に定義しま
    す。これを TRUE とすると、#pragma MCPP put_defines (#put_defines) で
    は、処理系の事前定義マクロはすべてコメントで囲んで出力します。ワンパ
    スコンパイラでは MCPP の出力をこれに与えると再度プリプロセスされるこ
    とになるので、二重定義を避けるためです。
    ただし、GCC V.3, V.4 はワンパスコンパイラとも言えますが、独立したプ
    リプロセッサを使うこともできるので、このマクロは FALSE としておきま
    す。
FNAME_FOLD
    Windows のようにファイル名の大文字と小文字が区別されないＯＳではこれ
    を TRUE と定義し、そうでなければ FALSE とします。

        [4.1.1.4]   処理系の言語仕様に応じた設定

EXPAND_PRAGMA
    #pragma 行の引数が STDC 以外であればマクロ展開の対象となる処理系では、
    これを TRUE に定義します。デフォルトでは FALSE としています。Visual
    C では #pragma 行の引数は常にマクロ展開の対象となるので、これは TRUE
    とします。C99 では #pragma の引数がマクロ展開の対象となるかどうかは
    implementation-defined で、C90 ではマクロ展開されないのが規定なので
    すが、しかし、MCPP は Visual C 用に限っては C99 でなくてもマクロ展開
    の対象とします（引数が STDC または MCPP で始まらない限り）。

HAVE_DIGRAPHS
    Digraphs 処理が実装されている場合は TRUE、そうでなければ FALSE とし
    ます。
STDC
    ターゲット処理系の事前定義マクロ __STDC__ のデフォルト値に定義します。
    __STDC__ が定義されていなければ 0 とします。
STDC_VERSION
    ターゲット処理系の事前定義マクロ __STDC_VERSION__ のデフォルト値に定
    義します。__STDC_VERSION__ が定義されていなければ 0L とします。

CHARBIT, UCHARMAX, LONGMAX, ULONGMAX
    ターゲット処理系の <limits.h> の CHAR_BIT, UCHAR_MAX, LONG_MAX,
    ULONG_MAX の値を書きます。<limits.h> がなくても定義は簡単です。

        [4.1.1.5]   Multi-byte character

  MBCHAR というマクロは multi-byte character の encoding を指定するもの
です。MCPP では下記の数種の encoding がすべて同時に実装されます。MBCHAR
はデフォルトの encoding を指定するだけで、実行時に encoding を環境変数・
オプション・#pragma で変更することができます（使い方については mcpp-
manual.txt の [2.3], [2.8], [3.4] を参照）。

MBCHAR
    ターゲットの multi-byte character（日本語では漢字）の encoding の種
    類を定義します。

        EUC_JP  :   日本の extended UNIX code (UJIS)
        SJIS    :   日本の shift-JIS (MS-Kanji)
        GB2312  :   中国の EUC-like な GB-2312（簡体字）
        BIGFIVE :   台湾の Big5（繁体字）
        KSC5601 :   韓国の EUC-like な KSC-5601 (KSX 1001)
        ISO2022_JP  :   ISO-2022-JP1 という国際規格の日本語
        UTF8    :   unicode の encoding の１種である UTF-8

    初めの５つはいずれも shift-states を持たない、１文字が２バイトを占め
    る encoding です。なお、multi-byte character, wide character の
    encoding が２バイトであるにもかかわらず、wchar_t が４バイトの型にな
    っている処理系もありますが、プリプロセッサは wchar_t の型には関知し
    ません。ソース上では multi-byte character や wide character が２バイ
    トを占めているので、それに従って処理をします。
    ISO-2022-* は shift-states を持つ encoding です。UTF-8 は２バイトの
    unicode を１バイトないし３バイトで encode するものです。漢字は３バイ
    トになります。
    MBCHAR を 0 に定義した場合、multi-byte character の処理をしないのが
    デフォルトの仕様になるだけで、環境変数・オプション・#pragma で実行時
    に変更されます。

SJIS_IS_ESCAPE_FREE
    コンパイラ本体が shift-JIS の処理をする場合は TRUE とし、しない場合
    は FALSE とします。
    Shift-JIS では漢字の２バイト目が '\\' と同じ 0x5c の値になることがあ
    ります。コンパイラ本体が shift-JIS を認識しない場合は、これを escape
    sequence と解釈してしまい、tokenization でエラーになります。
    SJIS_IS_ESCAPE_FREE を FALSE とすると、MCPP が処理を補います。すなわ
    ち、最終出力の時に、文字列リテラルまたは文字定数の中の shift-JIS 漢
    字第２バイトが 0x5c であった場合は、そこに 0x5c のバイトをもう１つ付
    加します。これによって、英語版のコンパイラを一応 shift-JIS に対応さ
    せることができます。
BIGFIVE_IS_ESCAPE_FREE
    同様に、コンパイラ本体が Big 5 の処理をする場合はこれを TRUE とし、
    しない場合は FALSE とします。
IS02022_JP_IS_ESCAPE_FREE
    同様に、コンパイラ本体が ISO-2022-JP の処理をする場合はこれを TRUE
    とし、しない場合は FALSE とします。IS0-2022-* では '\\' ばかりでなく、
    '\'' や '"' と一致するバイトも出現します。ISO2022_JP_IS_ESCAPE_FREE
    が FALSE の場合は MCPP は、'\\', '\'', '"' と一致するバイトの直前に
    すべて 0x5c のバイトを１つ挿入します。

  なお、multi-byte character に関するコンパイラの動作は実行する時の環境
によって変わる場合があります。自分の使う環境に合わせて設定してください。
これについては、mcpp-manual.txt の [2.8] も参照してください。

        [4.1.1.6]   ターゲットとホストに共通の設定

  次の２つは便宜上、PART 2 に書いてありますが、ターゲット処理系とホスト
処理系の双方が指定の型を持つ場合に TRUE とし、そうでない場合は FALSE と
します。

HAVE_LONG_LONG
    long long というデータ型を持つ処理系ではこれを TRUE とします。
    Visual C や Borland C 5.5 のように、long long はないが __int64 とい
    う同じサイズの型があり printf() で表示するための length modifier も
    用意されている場合は、これは TRUE とします。
HAVE_INTMAX_T
    intmax_t というデータ型が定義されていればこれを TRUE とします。

LL_FORM
    双方の処理系が long long を持っている場合は、ホスト処理系の最大の整
    数型の値を printf() で表示するための length modifier を文字列リテラ
    ルで定義します。C99 では "j" です。また、C99 では long long の
    length modifier は "ll" (ell-ell) です。Visual C の 2003 までと
    Borland C 5.5 では __int64 の値を表示する "I64" を使います。MinGW で
    も "I64" です。

        [4.1.2]     PART 2  ホストシステムの設定

  noconfig.H, configed.H ではターゲット処理系とホスト処理系とが同一であ
ると仮定していますが、異なる場合は PART 2 を書き直す必要があります。

HOST_HAVE_GETOPT, HOST_HAVE_STPCPY
    ホスト処理系のライブラリに getopt(), stpcpy() があればそれぞれ TRUE
    に、なければ FALSE に定義します。FALSE とされた関数には lib.c のもの
    が使われます。
FILENAMEMAX
    ホスト処理系の <stdio.h> の FILENAME_MAX の値です。FILENAME_MAX がな
    い場合は BUFSIZ としておいてかまいません。

  PART 1 にもホストとターゲットが同一と仮定している部分があるので、必要
ならそれを書き換えます。例えば次のようにホスト処理系の事前定義マクロを使
っている行です。

    #if _MSC_VER >= 1200

        [4.1.3]     PART 3  MCPP の動作仕様の設定

            [4.1.3.1]   新旧各種の動作モード

  system.H では MCPP の動作仕様を指定するマクロが定義されています。

  MCPP には mode という変数があり、これがマクロの展開方法、使えるディレ
クティブ、使える predefined マクロ等、プリプロセッサの根幹となる動作の仕
様を決めています。mode の値には OLD_PREP, KR, STD, POST_STD の４種があり
ます。
  MCPP の動作モードは実行時オプションで指定されます。MCPP をコンパイルす
る時には、これらの４つのマクロについては何も設定することはありません。し
かし、各種の設定を正しく行うためには４つの動作仕様の違いを理解することが
必要です。

OLD_PREP
    いわゆる "Reiser" model cpp の動作仕様です。
KR
    C90 以前の K&R 1st. のプリプロセス仕様です。
STD
    規格 (C90, C99, C++98) 準拠のプリプロセス仕様です。
POST_STD
    筆者が勝手に作ったプリプロセス仕様で、規格の首尾一貫しない規定を整理
    して単純化したものです。

  ここでは KR と OLD_PREP を合わせて pre-Standard モード、STD と
POST_STD を合わせて Standard モードと呼ぶことにします。各モードの仕様の
詳細については mcpp-manual.txt [2.1] を参照してください。

            [4.1.3.2]   動作モードの細部の指定

CPLUS
    -+ オプションで C++ のプリプロセッサとして動作させた時に、標準組み込
    みマクロ __cplusplus がこの値に事前定義されます。C++98 では 199711L
    です。-V オプションによって実行時に変更できます。
TFLAG_INIT
    STD モードでの trigraph 処理の初期状態を指定します。-3 オプションは
    その状態を反転させます。これを TRUE にすると、default で trigraph が
    認識され、-3 オプションで起動すると認識しません。FALSE の場合は逆に
    default で認識せず、-3 オプションで認識するようになります。
DIGRAPHS_INIT
    Standard モードでの digraph 処理の初期状態を指定します。-2 オプショ
    ンはその状態を反転させます。これを TRUE にすると、default で digraph
    が認識され、-2 オプションで起動すると認識しません。FALSE の場合は逆
    に default で認識せず、-2 オプションで認識するようになります。
    HAVE_DIGRAPHS == FALSE の処理系の場合、digraphs は MCPP が通常のトー
    クンに変換します。
OK_UCN
    STD モード で -V199901L または -+ オプションを指定した時に UCN
    (universal-character-name) を有効にするには、これを TRUE に定義しま
    す。デフォルトでは TRUE としています。
OK_MBIDENT
    STD モード で -V199901L オプションを指定したときに identifier 中に
    multi-byte character を使えるようにするには、これを TRUE に定義しま
    す。デフォルトでは FALSE としています。
DOLLAR_IN_NAME
    これを TRUE にすると、識別子中に $ を使えるようになります。

expr_t, uexpr_t
    最も大きい整数の型に typedef で定義します。intmax_t, uintmax_t とい
    う型があればそれに、そうでなくて long long, unsigned long long を持
    つ処理系ではそれに、そうでなくて __int64, unsigned __int64 を持つ処
    理系ではそれに、そうでなければ long, unsigned long に定義します。
EXPR_MAX
    uexpr_t の最大値に定義します。

  * UCN は C++, C99 の仕様で、Unicode の文字の値を \u または \U で始まる
    １６進 escape sequence で表記するものである（mcpp-manual.txt [3.7],
    cpp-test.txt [1.8], [3.5] 参照）。

        [4.1.3.3]   Translation limits の指定

RESCAN_LIMIT
    Standard モードでのマクロ展開時の再走査回数の限度を定義します。
    Standard モード では再走査回数は少ないので、あまり大きな値を設定する
    必要はありません。
PRESTD_RESCAN_LIMIT
    pre-Standard モードでのマクロ展開時の再走査回数の限度を定義します。
    pre-Standard モード では再帰的なマクロ展開によって無限ループが発生し
    えますが、それがこのリミットにひっかかります。
NBUFF
    論理行（ソースの物理行の行末の \ を取って接続した行）の最大長 +1 を
    定義します。コメントを a space に変換した後の行（コメントによって複
    数の論理行にまたがることもありうる）もこの長さにおさまっていなければ
    なりません。
NMACWORK
    マクロ展開の内部的なバッファのサイズを定義します。すなわち、１つの論
    理行中のマクロを展開した結果（マクロ呼び出しが複数行にまたがる場合は、
    それを展開した結果）はこのサイズにおさまっていなければなりません。こ
    れはまた、１つのマクロ定義の置換リストを内部的に記憶する際の最大長と
    しても使われます。
NWORK
    MCPP の出力する最大行長を定義します。これは compiler-proper の受け取
    れる最大行長+1 を越えてはいけません。また、NBUFF, NMACWORK の値を越
    えてもいけません。NWORK < NMACWORK の場合、マクロ展開後の行長がこれ
    を越えた時は、MCPP がこれ以下の行長に分割して出力します。文字列リテ
    ラルの長さは NWORK-2 の範囲に収まっていなければなりません（文字列リ
    テラルの長さというのは、char 配列の要素数のことではなく、ソース上で
    の文字列リテラルというトークンの長さである。両端の " を含み、\n 等は
    ２バイトと数える。ワイド文字列リテラルでは先頭の L も含む）。
IDMAX
    識別子の最大長を定義します。これより長い名前もエラーにはなりませんが、
    この長さに切り詰められます。
NMACPARS
    関数様マクロの引数の最大数を定義します。これは UCHARMAX よりも大きく
    はできません。
NEXP
    #if 行の式のカッコでくくられるネストレベルの限度を定義します（本当は
    ネストレベルがこれで直接決まるわけではない。正確には、式中の定数トー
    クンの数がこの２倍、演算子トークンの数がこの３倍まで使える。かっこは
    一対で２つと数える）。
BLK_NEST
    #if (#ifdef, #ifndef) section のネストレベルの限度（#if, etc. が何段
    階にネストできるか）を定義します。
INCLUDE_NEST
    #include のネストレベルの限度を定義します。#include の無限再帰をチェ
    ックするためのものです。同時にオープンできるファイルの数に関する OS
    の制限を超えていてもかまいません。
NINCLUDE
    サーチする include directory の最大数を定義します。
SBSIZE
    マクロを内部的に hash で分類して記憶する際の hash table の要素数を定
    義します。必ず２のベキ乗でなければなりません。マクロの数より小さくて
    も動作は正常にしますが、大きいほうが処理はやや速くなります。

  それぞれ大きい値にするほど仕様は上等になりますが、NWORK, NBUFF,
NMACWORK, SBSIZE は大きいとそれだけ大きなメモリを食います。実際のメモリ
消費はマクロ定義の量によってさらに増えてゆきます（それぞれのマクロ定義の
長さによって必要メモリが決まる。マクロ定義の内部的な形式は internal.H の
struct defbuf に書いてある）。
  NMACWORK, NEXP, RESCAN_LIMIT はスタックを消費します。
  他のものはメモリはさほど必要としませんが、system.H のデフォルトの値以
上にしても実用上の意味はほとんどないでしょう。
  C90, C99 の要求する translation limits の最低限度は system.H の最後の
ほうに書いてあります。C++98 の translation limits も書いてありますが、こ
れはＣと異なり、要求仕様ではありません。

    [4.2]       system.c

  主としてターゲット処理系に関するいくつかの設定を実装しています。

PATH_DELIM
    ＯＳの path-delimiter を定義しています。PATH_DELIM は \ としてはいけ
    ません（プログラムのつごうで）。Windows では / としています。ユーザ
    プログラムではもちろん \ も使えますが、それを内部的には / に変換しま
    す。
OBJEXT
    処理系の生成するいわゆるオブジェクトファイルの接尾子を文字列リテラル
    で定義します。UNIX 上の処理系の "o"、Windows 上の処理系の "obj" 等で
    す。これは -M* オプションを指定した時の makefile 用依存関係行の出力
    に使われるものです。

do_options()
    MCPP を起動する時のオプションを実装しています。まだ移植されていない
    処理系に移植する時には、その処理系付属のコンパイラドライバに合わせて、
    ここに何行か書き足すことが必要でしょう。do_options() に追加した時は、
    それに対応して次の set_opt_list(), usage() にも書き足します。
    do_options() は getopt() を呼び出します。そのため、１つのオプション
    文字は引数なしか引数ありのどちらかに決めなければなりません。-P と -P-
    といったオプションの使い方は原則としてできません（しかし、処理系付属
    のプリプロセッサとの互換性のために必要な場合は、無理やりできなくもな
    い。-M オプションの実装を参照）。また、-trigraphs といった長いオプシ
    ョンは t をオプション文字として rigraphs を引数とすることで実装する
    しかありません。
set_opt_list()
    MCPP のオプション文字を設定します。
usage()
    Usage 文が書かれています。モードごとのオプションがアルファベット順に
    並べられています。
set_sys_dirs()
    Include directory を設定しています。noconfig.H (configed.H) のマクロ
    C_INCLUDE_DIR?, CPLUS_INCLUDE_DIR? で指定された処理系固有のディレク
    トリのほか、UNIX 系ＯＳでの /usr/include, /usr/local/include もここ
    で設定しています（noconfig.H, configed.H のマクロ ENV_C_INCLUDE_DIR,
    ENV_CPLUS_INCLUDE_DIR で定義された名前の環境変数による include
    directory 指定は set_env_dirs() で設定される）。

do_pragma()
    #pragma の処理を実装しています。MCPP 自身が処理しない #pragma sub-
    directive はそのまま出力して compiler-proper に渡します。MCPP 自身が
    処理する #pragma MCPP debug 等はここから呼び出す関数で処理します。
    MCPP 自身が処理する #pragma sub-directive は原則として MCPP という名
    前で始まるようにしています。MCPP で始まる #pragma 行そのものは出力し
    ません。また #pragma once も出力しません。しかし、#pragma
    __setlocale 行は出力します。規格では処理系固有の拡張 directive は #
    pragma sub-directive として実装することになっています。
do_old()
    規格に合致しない preprocessing directive （#pragma sub-directive で
    ない #assert, #asm, #endasm, #include_next, #warning, #put_defines,
    #debug 等）が必要な場合は、その処理をする関数を書き足したうえで、こ
    こからそれを呼び出すようにします（ただし、GCC 用では #include_next,
    #warning は STD モード でも使えるようにしてある）。

    [4.3]       lib.c

  処理系によっては持っていないかもしれない、あるいはあっても仕様に問題の
あるライブラリ関数のソースがここに書いてあります。それぞれ、#if !
HOST_HAVE_XYZ 〜 #endif で囲んであるので、HOST_HAVE_XYZ == FALSE の時に
この XYZ 関数が使われます。

    [4.extra]   malloc()

  「kmmalloc -- デバッグ機能を持つ malloc()」というのは、私がＣで書いた
malloc(), free(), realloc(), calloc() の portable なソースです。これはメ
モリ効率を改善するとともに、デバッグのつごうを考えて書いてあります。デバ
ッグ用のルーチンも添付してあります。これをリンクしておくと、思わぬバグが
ひっかかってくることがあります。*1, *2
  noconfig/*.mak で -DKMMALLOC -D_MEM_DEBUG -DXMALLOC というオプションを
与えているのは、この私の malloc() 等とデバッグルーチンをリンクするための
ものです。これをリンクした MCPP がEFREEP, EFREEBLK, EALLOCBLK, EFREEWRT,
ETRAILWRT というエラー番号で途中で exit することがあれば、それは MCPP の
バグを意味します。
  Visual C の malloc() はかなり遅いので、なるべく kmmalloc を使いたいと
ころです。*2
  BSD_MALLOC, DB_MALLOC, MALLOC_DBG というマクロのどれかを 1 に定義して
MCPP をコンパイルすると、私の malloc() とは別のそれぞれデバッグ機能を持
った malloc() が使われます。いずれにしても、処理系付属のものではない
malloc() を使うには、コンパイルする前にライブラリを作っておかなければな
りません。これについては kmmalloc のドキュメントを見てください。

  *1 kmmalloc は次のところにある。
        http://download.vector.co.jp/pack/dos/prog/c/kmmalloc-2.5.1.lzh
  *2 CygWIN ではライブラリの組み立てが他の malloc() を使えないようになっ
    ているので、私の malloc() は使っていない。Visual C 2005 でも同様であ
    る。


☆　５．バグ報告と移植の報告　☆

    [5.1]       バグかどうか？

  プリプロセスの Standard C 適合性を検証するための Validation Suite を
MCPP といっしょに公開しています。Standard C のプリプロセスのすべての規定
を検証できるものにしたつもりです。もちろん、MCPP はこれを使ってチェック
してあります。それも、上記のすべての処理系でコンパイルしてチェックしてあ
ります。したがって、バグや誤仕様はほとんどないと思いますが、しかし、まだ
いくつか残っている恐れもあります。まだ移植されていない処理系に新しく移植
した場合は、処理系のバグにひっかかる可能性もあります。
  もし、不可解な動作が発見されたら、ぜひご報告ください。その際には、次の
点のチェックをお願いします。

  １．STD モードの場合、自分の Standard C 解釈を確かめるため、まず
Validation Suite を使ってみる。GCC / testsuite の使えるシステムでは、オ
プションを付けて configure して make check で自動テストができる。
  ２．自分の MCPP の移植に間違いはないかどうか、ドキュメントを確かめる。
  ３．バグを再現するサンプルソースを抽出する。
  ４．バグを引き出す部分を #pragma MCPP debug <args> と #pragma MCPP
end_debug ではさんで MCPP の動作をトレースしてみる。この <args> をさらに
増やしてより詳細にトレースしてみる。

  もし、"Bug: ..." という診断メッセージが出たら、それは間違いなく MCPP
または処理系の（たぶん MCPP の）バグです。また、たとえむちゃくちゃな「ソ
ース」でも、それを食わせることで MCPP が暴走するなら、それもバグです。
  もちろん、Standard C モード以外のモードの MCPP は Validation Suite で
は「間違い」だらけの動作をしますが、それは仕様です（それでも暴走はしない
はず）。どういう仕様かは [4.1.3] を見てください。

    [5.2]       malloc() 関連のバグチェック

  私が書いた kmmalloc という malloc() 等のライブラリがあります（[4.extra]
参照）。
  もし、私のこの malloc() 等をリンクした MCPP で 120 から 124（処理系に
よっては 2120 から 2124）のエラー番号で途中で exit することがあれば、そ
れは間違いなく MCPP または処理系の（たぶんライブラリ関数の）バグです。
  また、テストに使うサンプルソースのどこかに

    #pragma MCPP debug memory

と書いておくと、その個所および終了時にヒープメモリに関する情報が出力され
ますが、ここで Heap error: ... というメッセージが出ることがあれば、それ
も間違いなく MCPP または処理系のバグです。
  これらのバグが発見されたら、サンプルソースの各部分を #if 0 と #endif
ではさんでテストを繰り返し、バグを発生する部分を絞り込んでみてください。

    [5.3]       バグ報告を

  バグ報告には次のようなデータを付けてくださるようお願いします。

  １．MCPP を移植した処理系。
  ２．移植した方法（noconfig.H 等の設定）。
  ３．バグと思われるものを再現できるサンプルソース。
  ４．その処理結果。

    [5.4]       移植の報告を

  MCPP はほとんどの処理系に比較的簡単に移植できるように書いてあるつもり
です。しかし、私が持っている処理系は少数です。他の処理系への移植ではソー
スの書き足しが必要なはずです。それらの処理系への移植の報告をお待ちしてい
ます。それをソースにフィードバックしていきたいと思います。
  移植の報告は次のような形でお願いします。

  １．処理系。
  ２．noconfig.H (configed.H), system.H, system.c の設定。なるべくオリジ
ナルとの差分ファイルが良いが、簡単なものならメモでも可。

  正しく移植できたかどうかを確かめるには、compiler-specific-build では、
まずプリプロセッサを入れ替えて、ヘッダファイルの "pre-preprocess" の機能
を使って自分自身をリコンパイルしてみるのが手っ取り早いでしょう。
  さらに Validation Suite で STD モードのチェックをします。ただ、これは
ファイルの数が多いので、デバッグを繰り返す時には手間がかかりすぎます。デ
バッグ中はまず、n_std.c をコンパイルして、正常にコンパイル・実行されるか
どうかを見ます。処理系付属のコンパイラドライバでは MCPP に渡す方法のない
オプションもありますが、それについては mcpp-manual.txt の [2.1] を見てく
ださい。先に MCPP を通してからコンパイルする手もあります。
  もしこれがうまくいかない場合は、 n_std.t というサンプルを使って、どこ
が悪いのか、目でチェックします。これがうまくいったら、e_std.t, m_*.t,
unspcs.t, warns.t, misc.t もチェックします。"post-Standard" モードでは
n_post.t, e_post.t を使います。
  これらを cpp -QCz23 というオプションを付けて処理します（post-Standard
モードでは -3 は不可）。STDC == 0 でコンパイルしてあれば -S1 -V199409L
オプションも付けます。-C オプションでコメントも出力されるので、処理結果
が期待通りかどうかがすぐわかります。
  -Q オプションで診断メッセージは mcpp.err というファイルに出力されるの
で、それをページャー等で読みます。
  -z オプションで、ヘッダファイルの出力は省略されます。
  -2 -3 で digraph と trigraph が有効になります。-S1 -V199409L で
__STDC__ が 1 に __STDC_VERSION__ が 199409L になります。
  C99 対応のテストをするためには、-V199901L オプションを付けて n_std99.t,
e_std99.t のチェックをします。
  Validation Suite の cpp_test.c というプログラムを使うと、n_*.c, i_*.c
のサンプルのテストを自動的に行うことができます（ただし、これは○×をつけ
るだけで、詳細はわからない。また、e_*.?, u_*.?, unspcs.?, warns.? 等のテ
ストは含まれない。MCPP 自身のテストをするためには、n_std.c をコンパイル
するほうが早い）。

  なお、Validation Suite は GCC の testsuite に対応しています。したがっ
て、MCPP を GCC のどれかのバージョンに移植した場合は、GCC / testsuite が
インストールされていれば、GCC のプリプロセッサを MCPP に置き換えると、
MCPP の自動テストができます。これについては cpp-test.txt [2.2.3], mcpp-
manual.txt [3.9.5]-[3.9.7] を見てください。

    [5.5]       GCC 以外の処理系での configure の情報を

  MCPP は UNIX 系システムでは configure スクリプトが使えます。しかし、
UNIX 系システムでの GCC 以外の処理系については私はまったく知らないので、
configure ではいくつかのオプションを指定してもらわなければなりません。
  これらのオプションで指定する内容については、その処理系を使っている人は
知っているか、または調べることができるはずです。おわかりの方はぜひ教えて
ください。Configure に取り込んでゆきたいと思います。
  Configure については INSTALL をご覧ください。

    [5.6]       データを送ってくれれば移植してみます

  移植がうまくいかない場合は、そのようすをお知らせください。
  次のデータを付けてくれれば、移植したソースをお返しできるかもしれません。
Configure の使える環境では、これらのデータのうちのかなりの部分を
configure によって知ることができます。
  なお、C90 (ANSI C) に対応していない処理系は、MCPP V.2.6 からは移植の対
象から外しました。

  1.  ＯＳとそのパスリストの形式（私は UNIX 系, DOS/Windows 系, OS-9 し
か知らない）。
  2.  処理系の名前とバージョン。
  3.  基本文字セットは ASCII か。そうでなければどういう文字セットか。
Multi-byte character（漢字）の encoding はシフト JIS か EUC-JP か、それ
とも何か。Shift-JIS のように <backslash> と同じコードが multi-byte
character に含まれる encoding の場合、コンパイラ本体はそれを認識するか。
  4.  Shell（コマンドプロセッサ）は大文字と小文字を区別するか。
  5.  ファイル名の大文字と小文字は区別されるか。
  6.  実装したい実行時オプション。コンパイラドライバから渡されるオプショ
ン。プリプロセッサ単体で動かす時のオプション（getopt() で実装できないも
のは不可）。
  7.  プリプロセッサが分離されている処理系か、それともいわゆるワンパスコ
ンパイラか。
  8.  その処理系の事前定義マクロとその値。C++ の時はどうなるか（コンパイ
ラドライバから -D オプション等でプリプロセッサに渡されるマクロと、プリプ
ロセッサ自身が事前定義するマクロとを区別すること）。
  9.  long long 型はあるか。long long がある場合、printf() での long
long の length modifier は何か。long long がなくても同じサイズの型がある
か。
  10.  <limits.h> があるなら、CHAR_BIT, UCHAR_MAX, LONG_MAX, ULONG_MAX
の値。<limits.h> がなければこの４つに相当する値（１バイトが８ビットなら
system.H のデフォルト値と同じはず）。
  11.  <stdio.h> に FILENAME_MAX があればその値。
  12.  #pragma 行の引数はマクロ展開の対象となるか。
  13.  Include directory を指定する環境変数にはどういう名前を使うか。環
境変数で複数のパスを記述する時の separator には何を使うか。
  14.  通常使う include directory。#include でヘッダファイルをサーチする
時の規則。
  15.  必要な関数で、ライブラリに無いものがあるか。
  16.  コンパイラ本体は digraph を認識するか。
  17.  識別子に $ を使うか。
  18.  #asm, #endasm はあるか。これではさまれたブロックのコンパイラ本体
への受け渡し形式はどうか。その他の規格外 directive にはどんなものがある
か。
  19.  プリプロセッサで処理すべき #pragma sub-directive には何があるか。
  20.  コンパイラ本体が受け取れる行長はどのくらいまでか（Validation
Suite にある test-l/l_37_8.c をコンパイルするとわかる）。
  21.  コンパイラ本体では、識別子は何バイトまで識別されるか。
  22.  コンパイル後、リンク前の「オブジェクトファイル」の接尾子は何か
（UNIX 上の処理系の .o や Windows 上の処理系の .obj に相当するもの）。
  23.  次の t_line.c というサンプルをプリプロセッサだけに通した結果（単
体プリプロセッサを使うか、またはオプションでプリプロセス後の出力を指定す
る）。これは行番号とファイル名の情報をコンパイラ本体に渡す方法を見るため
のものである。<stdio.h> の内容は長すぎるので、途中をカットして最初の１０
〜２０行と最後の１０〜２０行があれば十分である。
  さらに、#line 1000 が処理された結果が #line 1000 "t_line.c" とならず #
1000 "t_line.c" とかその他の形式になる処理系では、その部分を #line 1000
"t_line.c" と書き替えてコンパイラ本体に渡して、これを認識できるかどうか
を見る（#line 1000 "t_line.c" でエラーにならなければ error line; の行で
エラーメッセージが出るはずであるが、その時に行番号がどう出るか）。

/* t_line.c */
#include    <stdio.h>

#line 1000

    error line;

main( void)
{
    return  0;
}

  ホスト処理系とターゲット処理系が違う場合はその双方について上記のデータ
があれば、何とかなるでしょう。
  こうして並べてみると、チェックすべきことがずいぶんたくさんありますね。
しかし、多くの処理系では移植ずみの処理系と共通の特性が多いでしょうから、
一応動作するだけの移植であればさほどの手間ではないはずです。比較的手間の
かかるのは実行時オプションと #pragma、さらに規格外仕様の実装です。これは
一応動作するようになってから、徐々にやってゆくこともできます。唯一面倒な
のは、処理系のバグにひっかかった場合です。

    [5.7]       検証セットによる他の処理系のテスト報告を

  私が持っている処理系のプリプロセッサを私の検証セットでテストした結果は、
cpp-test.txt [5] にまとめてあります。
  その他の処理系についてテストした結果をお知らせください。項目が多いので
かなりの手間ですが。
  cpp_test.c によるテストであれば手間はかからないので、これだけでもお願
いします。GCC の場合は、検証セットによる自動テストができます。

    [5.8]       改善のご意見を

  バグ報告のほかにも、MCPP の使い勝手、診断メッセージ、MCPP のソース、
Validation Suite、私の Standard C 解釈、ドキュメントの書き方、などについ
てご意見をお寄せください。
  趣味で作ったプリプロセッサですが、V.2.0 までだけでも６年半もかけて凝り
に凝った労作です。凝りついでにできるだけ良いものにしたいと思っています。
Ｃプリプロセッサについては、私の持っていない処理系への移植とテスト以外は、
やって意味のあることはほとんどすべてやったつもりです。多少とも問題が残っ
ていれば、手を入れたいと思います。
  Martin Minow のソースはとてもきれいな、クセのない、わかりやすいもので、
これを読むだけでも私にとってはずいぶん勉強になりました。
  こういうものに興味を持つ人はかなり限られていると思いますが、多くのコメ
ントと情報をお待ちしています。
  ご意見と情報は

    http://mcpp.sourceforge.net/

の "Open Discussion Forum" またはメールでお願いします。


☆　６．MCPP の長い道のり　☆

    [6.1]       構想３日、制作６年

  1992/01 に DECUS cpp をいじりだした時には、こんな長丁場になるとは夢に
も思いませんでした。正月休みにちょこっとバージョンアップしてみようと思っ
ただけだったのです。
  やり始めて、ソースをちゃんと読まないとダメだとわかり、２か月くらいかけ
て読みました。読みがいのあるソースだったからでもあります。次にいくつかの
仕様を C90 対応にバージョンアップしました。ここまでは当初の目的の通りで
した。
  しかし、ここで私は自分が C90 のプリプロセス仕様を正確には知っていない
ことに気付きました。P. J. Plauger & Jim Brodie "Standard C" (1989) を読
んだところ、function-like マクロの展開方法は、私の先入見をひっくり返すも
のでした（ある邦訳書はここを誤訳していたが）。そこで規格書を買って、プリ
プロセスに関する難解な文章をくり返し読みました。その結果、C90 のプリプロ
セスは伝統的なものとは多くの点で異なっていることがわかりました。#, ## 演
算子が追加されたことは、そのほんの一部分にすぎなかったのです。
  ことに function-like マクロの展開ルーチンにはかなり頭を悩ましました。E.
Ream の cpp のソースを参考に２〜３週間考えて、C90 用マクロ展開ルーチンを
新しく書きました。私がプログラムのアルゴリズムでこんなに一生懸命考えたの
は、後にも先にもないことです。1992/04 のことでした。
  さて、これで峠を越して、今度こそ cpp いじりはおしまいだと思ったのです
が、ところがそれからさらに６年あまりたってしまいました。といっても、この
間にはさほど頭を悩ます問題はなかったのです。にもかかわらず、時間はずいぶ
んかかりました。考えるだけ考えたら飽きてきて、cpp いじりに集中しなくなっ
たせいもあります。しかし、それだけではありません。この間にやったのは次の
ようなことです。

  １．仕様をさらに明確にする。Standard モードでは規格に完全に対応させる。
  ２．Standard C のモードを中心にプログラム構造・データ構造を再構成する。
  ３．Portability を上げるため、ソースのスタイルを変える。
  ４．デバッグをする。処理系のバグや不備に対処する。
  ５．テストプログラムすなわち Validation Suite を作る。
  ６．他の処理系のテストをする。
  ７．ドキュメントを書く。
  ８．1997/07 には新しいパソコンを買ったため、初めて使う WindowsNT/95, X
Window System とそのソフトのインストールと習得に追われた。そうしているう
ちに C99-1997/11 draft が出て、これへの対応が必要となった。

  中でも時間のかかったのはドキュメントでした。ことに後半の４年くらいはソ
ースをいじった時間はほんの少しで、ドキュメント書きが作業の大半を占めてい
ました。おかげで大変な分量になってしまいましたが、しかし、時間がかかった
のは量が多いせいばかりではありません。ドキュメントを書いていると、仕様の
不明確なところが次々と出てくるのです。そのたびに規格書を読み返し、ソース
を少しずついじりました。ソースをいじった時間は少なくても、回数は少なくあ
りません。規格書もプリプロセス規定だけではなく、全体を ANSI C の
Rationale も含めてよく読んでみました。私はプリプロセッサを作ることを通し
て C90 の勉強をしたようなものです。さらにはこれを通して、C90 の規定の問
題点も明確に把握することができました。
  テストプログラムは初めは簡単なサンプルを何本か書いただけでした。ところ
が、書いて cpp をテストするたびに意外なバグが見つかるのです。そこで、C90
プリプロセスの全規定をテストする Validation Suite を書くことにしました。
そして、Valadation Suite を書くことを通して、C90 の問題点がさらに明らか
になってきました。C90 の不規則な部分に対応するのは、自分にとってはわずら
わしいばかりであまり意味のないことでしたが、それよりも意味のある部分のほ
うがはるかに多かったことは確かです。
  この作業を通して私が学んだのは、次のようなことです。

  １．プログラムの仕様は、詳細なドキュメントを書き終えるまで確定しない。
  ２．プログラムのデバッグは、全仕様をテストするサンプルが完成するまで終
わらない。

  この考え方は完全主義的なものです。世の中のことは完全主義ではうまくゆか
ないものが多く、プログラムも例外ではありませんが、中には完全主義が重要な
意味を持つ分野もあります。言語処理系はその一つでしょう。
  趣味だから何年もかけて徹底的にやることができたとも言えます。それにして
も６年半は長すぎました。こんなに時間をかけて完全なプログラムを作って、い
ったいだれが使うのだろうという疑問がずっと続いていました。趣味で作るプロ
グラムとしては、このくらいが規模の限度なのでしょう。
  しかし、MCPP はもう作ってしまったので、今後もメンテナンスをしていくつ
もりです。せっかくですから皆さん、コメント、報告、移植をお願いします。

    [6.2]       V.2.3 へ

  V.2.0 を公開した後、さらに V.2.1, V.2.2, V.2.3 と update を繰り返しま
した。C99 や正式に承認された ISO / C++ に対応させたり、対応処理系を増や
したり、バグをとったりというのがその内容です。
  V.2.2 までは簡単に update できていました。V.2.2 は V.2.0 から３か月し
かたっていません。ところが、V.2.3 は V.2.2 から４年あまりもたってしまい
ました。私の身辺が多忙になり、時間がとれなくなったのが主な原因です。2000
/07 に 60 歳になって、仕事を週４日に減らしてから、いくらか時間がとれるよ
うになり、cpp いじりに復帰しました。
  V.2.3 は時間だけでなく、手間も比較的かかっています。GCC V.2.9x に実装
してみたところ、GCC / cpp との互換性確保のためにかなり手を加えなければな
らないことがわかったからです。多くのオプションを追加し、拡張仕様を実装し
ました。また、一部のエラーをウォーニングに格下げしたり、頻発するウォーニ
ングをデフォルトのウォーニングクラスからはずしたりして、規格による制限を
緩和しています。
  こうした変更の多くは後向きのものであり、楽しいものではありませんでした。
ことに C90 以前の "traditional" な仕様の一部を C99 の仕様と両立させなけ
ればならないというのは、はなはだ不本意なことでした。しかし、これが現在の
オープンソース界の実情であれば、それにある程度合わせるのはやむをえません。
  規格による制約を緩和したことで、他の処理系用の版も、処理系付属のプリプ
ロセッサと置き換えて使うためには使いやすくなったと思います。

    [6.3]       「未踏ソフトウェア創造事業」に採択

  V.2.3 への update の途中で、MCPP および Validation Suite は情報処理振
興事業協会 (IPA) の平成１４年度「未踏ソフトウェア創造事業」というものに
採択されました。たまたまこの事業のことを知ったので応募してみたところ、新
部 裕・プロジェクトマネージャが採択してくれたのです。こうして 2002/07 か
ら 2003/02 までは IPA の資金援助と新部ＰＭの助言のもとに、開発が進められ
ることになりました。ドキュメントの英訳も、ハイウェルが引き受けてくれるこ
とになりました
  比較的小さいソフトウェアながらも、これだけ時間をかけ、私のライフワーク
のようになってしまったものです。その完成度には自信がありましたが、世に出
る機会がなく、残念な思いをしてきました。その機会がついに与えられたのです。
私はこのプロジェクトを遂行するため、仕事を週３日に減らしました。
  私がこのプロジェクトでやることとして考えたのは、次のようなことでした。

  １、英語版のドキュメントを作成する。それを使って、MCPP と検証セットを
国際的な評価の場に出してゆく。Ｃ処理系の大半が外国製となっている現状では、
英語版ドキュメントの存在は評価と普及のために必須だからである。
  ２、移植の対象を広げる。これまで対応してきた処理系の新しいバージョンに
対応させるほか、市販の主要な処理系への移植を進める。

  さらに新部 PM から次の提案がありました。

  １、GCC 3.x にも移植し、さらにその testsuite で私の検証セットが利用で
きるようにする。
  ２、開発をオープンな形で進めてゆく。

  私自身もこれらはぜひやりたいことであるので、喜んで計画に追加しました。
  ところが、私の計画は遅延に遅延を重ねました。まず、ディスククラッシュに
見舞われました。また、何か新しいことをするたびに使ったことのないソフトウ
ェアを使って、そのたびに時間がかかりました。GCC をソースからコンパイルし
たのも初めてですが、これはいくつかのトラブルに見舞われました。大量のドキ
ュメントの更新と大量の英訳のチェックと修正にも、かなりの時間がかかりまし
た。その上、母の入院という事態まで発生しました。プロジェクトは市販の処理
系への対応等、計画の一部を断念する結果となりました。
  私はこれまで一つの穴を深く掘ってゆくようなことしかしてこなかったので、
穴を少し広げようとするとひどく手間がかかってしまうのです。アマチュアプロ
グラマが何かを掘り下げるには、こういうやり方をしなければできることではあ
りません。しかし、その成果を世に出すためには、穴をいくらか広げなければな
らないのでした。
  穴を広げる過程で、私は新部 PM の助言と励ましを得て、いくつかの未経験の
ソフトウェアを習得し、開発の前線というものに触れることができました。自分
の文章がこなれた英文に翻訳されて戻ってくるのも、大変うれしいことでした。
時間に追われるのは苦しいことですが、内容はどれも新鮮で楽しいことでした。

  「未踏ソフトウェア創造事業」はこれでおしまいではありませんでした。平成
１５年度にも、伊知地 宏・プロジェクトマネージャが MCPP を継続プロジェク
トとして採択してくれたのです。こうして、前年度の積み残しの課題を初めとし
て、私にとっては未経験の領域のいくつかの課題に取り組むこととなりました。
  今回も私の６年前のパソコンにトラブルが発生し、ハードウェアと OS を
upgrade する過程でさらにいくつかのトラブルに見舞われました。未経験のソフ
トウェアの習得にも時間を要し、開発はやはり遅れ気味でした。いったん退院し
て比較的元気になっていた母の容態が、プロジェクトが大詰めに近づくのと並行
して以前にも増して悪くなってきたことも、心配の種でした（母は 2004 年 2
月に死去した）。しかし、伊知地ＰＭが目標を無理のないところに設定してくれ
たおかげで、あわてずにじっくりと課題に取り組むことができました。
  Visual C++ への移植、configure スクリプトの作成、多様な multi-byte
character encoding への対応等の課題を達成することができました。また、ソ
ースコードの整理という目立たないながらも作者としてはこだわりのある課題に
も取り組みました。日本語版と英語版のドキュメントの更新という手間のかかる
作業も、ハイウェルの協力を得て達成することができました。
  この成果によって、私は伊知地ＰＭから何と「スーパークリエータ」という評
価を受けることができました。私の実力にとっては過分の評価ですが、長年にわ
たる MCPP の積み重ねを認めていただいたものと思い、大変喜んでいます。

  ２年近くにわたる「未踏ソフトウェア」のプロジェクトによって、MCPP は世
界一高品質な C/C++ プリプロセッサに仕上がったつもりです。熟年のアマチュ
アプログラマとして非力ながらもよくやったと自分では納得しています。

  未踏ソフトウェアのプロジェクトが終わってからも、MCPP の改良作業は続け
られています。まだいくつかの課題が残っています。これらの課題を達成し、
MCPP を普及させるために、今後も着実に取り組みを続けてゆくつもりです。

                                                                   [eof]
